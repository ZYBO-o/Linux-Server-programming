网络程序需要处理的第三类事件是定时事件，比如定期检测一个客户连接的活动状态。服务器程序通常管理着众多定时事件，因此有效地组织这些定时事件，使之能在预期的时间点被触发且不影响服务器的主要逻辑，对于服务器的性能有着至关重要的影响。

为此，我们要 **将每个定时事件分别封装成定时器，并使用某种容器类数据结构，比如链表、排序链表和时间轮，将所有定时器串联起来，以实现对定时事件的统一管理。**

本章主要讨论的就是两种高效的管理定时器的容器： **时间轮** 和 **时间堆** 。 不过，在讨论如何组织定时器之前，我们先要介绍定时的方法。定时是指在一段时间之后触发某段代码的机制，我们可以在这段代码中依次处理所有到期的定时器。换言之，定时机制是定时器得以被处理的原动力。Linux提供了三种定时方法，它们是：

❑ socket选项SO_RCVTIMEO和SO_SNDTIMEO。

❑ SIGALRM信号。

❑ I/O复用系统调用的超时参数。

## 一.socket选项SO_RCVTIMEO和SO_SNDTIMEO

socket选项SO_RCVTIMEO和SO_SNDTIMEO，它们分别用来设置socket接收数据超时时间和发送数据超时时间。因此，这两个选项仅对与数据接收和发送相关的socket专用系统调用有效。

SO_RCVTIMEO和SO_SNDTIMEO选项的作用：

<div align = center><img src="../../Accumulation/图片/UNIX28.png" width="800px" /></div>

由表11-1可见，在程序中，我们可以根据系统调用的返回值以及errno来判断超时时间是否已到，进而决定是否开始处理定时任务。

### 例子实现

:large_blue_diamond: 定义timeout_connect函数，根据IP地址，端口号和超时时间创建socket文件

```c++ 
const char* ip = argv[1];
int port = atoi( argv[2] );

int sockfd = timeout_connect( ip, port, 10 );
```

:diamond_shape_with_a_dot_inside: **timeout_connect定义**

```c++
int sockfd = socket( PF_INET, SOCK_STREAM, 0 );
assert( sockfd >= 0 );

//通过选项SO_RCVTIMEO和SO_SNDTIMEO所设置的超时时间的类型是timeval，这和select系统调用的超时参数类型相同
struct timeval timeout;
timeout.tv_sec = time;
timeout.tv_usec = 0;
socklen_t len = sizeof( timeout );
ret = setsockopt( sockfd, SOL_SOCKET, SO_SNDTIMEO, &timeout, len );
assert( ret != -1 );

ret = connect( sockfd, ( struct sockaddr* )&address, sizeof( address ) );
```

:one: 创建timeval对象timeout，设定时间。

:two: 利用setsockopt函数设置sockfd文件描述符，设置为具有定时功能的对象

:three: 利用新功能的sockfd创建连接socket文件描述符

```c++
if ( ret == -1 )
{
    //超时对应的错误号是EINPROGRESS。下面这个条件如果成立，我们就可以处理定时任务了
    if( errno == EINPROGRESS ){
        printf( "connecting timeout\n" );
        return -1;
    }
    printf( "error occur when connecting to server\n" );
    return -1;
}
```

:one: 如果返回值的错误类型是EINPROGRESS，则处理定时任务。

---



## 二.SIGALRM信号

alarm和setitimer函数设置的实时闹钟一旦超时，将触发SIGALRM信号。因此，我们可以利用该信号的信号处理函数来处理定时任务。

但是，如果要处理多个定时任务，就需要不断地触发SIGALRM信号，并在其信号处理函数中执行到期的任务。一般而言，SIGALRM信号按照固定的频率生成， **即由alarm或setitimer函数设置的定时周期T保持不变。如果某个定时任务的超时时间不是T的整数倍，那么它实际被执行的时间和预期的时间将略有偏差。因此定时周期T反映了定时的精度。**

### 1. 基于升序链表的定时器

定时器通常至少要包含两个成员：

+ 超时时间（相对时间或者绝对时间）
+ 任务回调函数

>  有的时候还可能包含回调函数被执行时需要传入的参数，以及是否重启定时器等信息。

如果使用链表作为容器来串联所有的定时器，则每个定时器还要包含指向下一个定时器的指针成员。进一步，如果链表是双向的，则每个定时器还需要包含指向前一个定时器的指针成员。





### 2.处理非活动连接





## 三.I/O复用系统调用的超时参数

Linux下的3组I/O复用系统调用都带有超时参数，因此它们不仅能统一处理信号和I/O事件，也能统一处理定时事件。

但是由于I/O复用系统调用可能在超时时间到期之前就返回（有I/O事件发生）， 所以如果我们要 **利用它们来定时，就需要不断更新定时参数以反映剩余的时间。**

```c++
#define TIMEOUT 5000

int timeout = TIMEOUT;
time_t start = time( NULL );
time_t end = time( NULL );
while( 1 )
{
    printf( "the timeout is now %d mill-seconds\n", timeout );
    start = time( NULL );
    int number = epoll_wait( epollfd, events, MAX_EVENT_NUMBER, timeout );
    if( ( number < 0 ) && ( errno != EINTR ) )
    {
        printf( "epoll failure\n" );
        break;
    }

    //如果epoll_wait成功返回0，则说明超时时间到，此时便可处理定时任务，并重置定时时间
    if( number == 0 )
    {
        // timeout
        timeout = TIMEOUT;
        continue;
    }

    //如果epoll_wait的返回值大于0，则本次epoll_wait调用持续的时间是(end-start)*1000 ms，
    //我们需要将定时时间timeout减去这段时间，以获得下次epoll_wait调用的超时参数
    end = time( NULL );
    timeout -= ( end - start ) * 1000;
  
    //重新计算之后的timeout值有可能等于0，说明本次epoll_wait调用返回时，不仅有文件描述符就绪，而且其超时时间也刚好到达，
    //此时我们也要处理定时任务，并重置定时时间
    if( timeout <= 0 )
    {
        // timeout
        timeout = TIMEOUT;
    }

    // handle connections
}
```

---



## 四.高性能定时器—时间轮

### 1.基本概念

基于排序链表的定时器存在一个问题：添加定时器的效率偏低。而时间轮可以解决这个问题。一种简单的时间轮如图11-1所示：

<div align = center><img src="../../Accumulation/图片/UNIX29.png" width="700px" /></div>

上图所示的时间轮内：

+ （实线）指针指向轮子上的一个槽（slot）。它以恒定的速度顺时针转动，每转动一步就指向下一个槽（虚线指针指向的槽）；
+ 每次转动称为一个滴答（tick），一个滴答的时间称为时间轮的槽间隔si（slot interval），它实际上就是心搏时间。
+ 该时间轮共有N个槽，因此它运转一周的时间是N * si。
+ 每个槽指向一条定时器链表，每条链表上的定时器具有相同的特征：它们的定时时间相差N*si的整数倍。时间轮正是利用这个关系将定时器散列到不同的链表中。

假如现在指针指向槽cs，我们要添加一个定时时间为ti的定时器，则该定时器将被插入槽ts（timer slot）对应的链表中：

<div align = center> ts = (cs + (ti / si)) % N </div>

基于排序链表的定时器使用唯一的一条链表来管理所有定时器，所以插入操作的效率随着定时器数目的增多而降低。

**而时间轮使用哈希表的思想，将定时器散列到不同的链表上。这样每条链表上的定时器数目都将明显少于原来的排序链表上的定时器数目，插入操作的效率基本不受定时器数目的影响。**

很显然，对时间轮而言，要提高定时精度，就要使si值足够小；要提高执行效率，则要求N值足够大。

### 2.代码分析





### 3.性能分析

对时间轮而言：

+ 添加一个定时器的时间复杂度是O(1)

+ 删除一个定时器的时间复杂度也是O(1)

+ 执行一个定时器的时间复杂度是O(n)

  > 但实际上执行一个定时器任务的效率要比O（n）好得多，因为时间轮将所有的定时器散列到了不同的链表上。
  >
  > 时间轮的槽越多，等价于散列表的入口（entry）越多，从而每条链表上的定时器数量越少。
  >
  > 此外，我们的代码仅使用了一个时间轮。当使用多个轮子来实现时间轮时，执行一个定时器任务的时间复杂度将接近O(1)

---



## 五.高性能定时器—时间堆

### 1.基本概念

前面讨论的定时方案都是以固定的频率调用心搏函数tick，并在其中依次检测到期的定时器，然后执行到期定时器上的回调函数。

设计定时器的另外一种思路是：

+  **将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔。**

这样，一旦心搏函数tick被调用，超时时间最小的定时器必然到期，我们就可以在tick函数中处理该定时器。然后，再次从剩余的定时器中找出超时时间最小的一个，并将这段最小时间设置为下一次心搏间隔。如此反复，就实现了较为精确的定时。最小堆很适合处理这种定时方案。

### 2.最小堆操作

堆的操作见 [堆排序]()

### 3.代码分析





### 4.性能分析

对时间堆而言：

+ 添加一个定时器的时间复杂度是O(lgn)
+ 删除一个定时器的时间复杂度是O(1)
+ 执行一个定时器的时间复杂度是O(1)

因此，时间堆的效率是很高的。